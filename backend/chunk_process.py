import glob
import os
import subprocess
import progressbar
import psutil
import backend.file_content_module as fcm
import signal


def kill_proc_tree(pid, sig=signal.SIGTERM, include_parent=True,
                   timeout=None, on_terminate=None):
    """Kill a process tree (including grandchildren) with signal
    "sig" and return a (gone, still_alive) tuple.
    "on_terminate", if specified, is a callback function which is
    called as soon as a child terminates.
    """
    assert pid != os.getpid(), "won't kill myself"
    parent = psutil.Process(pid)
    children = parent.children(recursive=True)
    if include_parent:
        children.append(parent)
    for p in children:
        try:
            p.send_signal(sig)
        except psutil.NoSuchProcess:
            pass
    gone, alive = psutil.wait_procs(children, timeout=timeout,
                                    callback=on_terminate)
    return gone, alive


def create_segments(numberOfSegment, baseName):
    """ Use the splitIntoNSegments function of imod to create folder ready of subtomogram averaging
    :param numberOfSegment: int
    :param baseName: string
    """
    path_to_mtv_list = os.path.relpath(glob.glob("*RefP*.csv")[0])

    command = "splitIntoNSegments {nbr} {name}_PtsAdded_Twisted.mod {mtv}".format(nbr=numberOfSegment, name=baseName,
                                                                                  mtv=path_to_mtv_list)
    result = subprocess.run(command.split(" "), stdout=subprocess.PIPE, text=True)
    fcm.log_file_append(result)


def lancer_parser_segment(base_name_with_segment, segment_number, working_dir):
    """ Parse the prm using prmParser from imod to prepare com files for chunk processing
    :param base_name_with_segment: string
    :param segment_number: int
    :return: always True
    """
    # User must be in folder containing segment folder
    os.chdir(working_dir)

    # Parser
    command_parser = "prmParser " + base_name_with_segment + ".prm"
    result = subprocess.run(command_parser.split(" "), stdout=subprocess.PIPE,
                            text=True)  # should be waiting before doing next (independant of shell = True)
    fcm.log_file_append(result)
    os.chdir("..")
    return True


def lancer_parser(base_name):
    """ Parse the prm using prmParser from imod to prepare com files for chunk processing
    :param base_name: string
    :return: always True
    """
    # Parser
    command_parser = "prmParser " + base_name + ".prm"
    result = subprocess.run(command_parser.split(" "), stdout=subprocess.PIPE, text=True)
    # should be waiting before doing next (independant of shell = True)
    fcm.log_file_append(result)
    return True


def lancer_process_chunk_fullmt(base_name: str, number_core, stop):
    """ Use the processchunks functions from imod to process chunks using com files generated by prm parser
    :param stop: bool
    :param number_core: int
    :param base_name: str
    :return: a pointer to a stream
    """
    # Generate average
    command_process = "processchunks -n 0 -g -P " + "localhost:" + str(
        number_core) + " " + base_name
    command = command_process.split(" ")
    proc = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, bufsize=1,
                            universal_newlines=True, start_new_session=True)  # popen necessary for parallel processing
    log = open("TotalLog_MainMT.txt", 'a')
    try:
        for line in proc.stdout:
            if 'DONE SO FAR' in line or 'pid' in line:  # Customize this condition to print specific lines
                print("MAIN MT: " + line.lower(), end='')
            else:
                log.write(line)
            if stop():
                raise KeyboardInterrupt
    except KeyboardInterrupt:
        # Handle Ctrl+C gracefully using kill_proc_tree function
        print("Ctrl+C received. Terminating process for main MT.")
        log.close()
        # process.terminate()
        print("Proc PID is :" + str(proc.pid))
        gone, alive = kill_proc_tree(proc.pid, signal.SIGKILL)
        for p in alive:
            p.kill()
    finally:
        log.close()


def lancer_process_chunk_segment(base_name: str, segment_number: int, number_core, wd: str, stop, lock):
    """ Use the processchunks functions from imod to process chunks using com files generated by prm parser
    :param lock: a threading lock
    :param stop: a lambda function to signal to the thread
    :param wd: a string for working directory
    :param number_core: number of core to use
    :param base_name: str
    :param segment_number: which segment number is it
    """
    base_name_with_segment = base_name + '_S' + str(segment_number)

    command_process = "processchunks -n 0 -g -P " + "localhost:" + str(
        number_core) + " " + base_name_with_segment  # Number of processor to use for the command.
    command = command_process.split(" ")
    # Generate average
    # User must be in folder containing segment folder. Using a lock to prevent shenanigans when multiple threadings
    lock.acquire()
    os.chdir(wd)
    print("Before the subprocess is called, I am in " + wd)
    proc = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, bufsize=1,
                            universal_newlines=True, start_new_session=True)  # popen necessary for parallel processing

    lock.release()
    log = open("TotalLog_Segment" + str(segment_number) + ".txt", 'a')
    bar = progressbar.ProgressBar(max_value=progressbar.UnknownLength, redirect_stdout=True)
    try:
        k = 0
        for line in proc.stdout:
            if 'DONE SO FAR' in line or 'pid' in line:  # Customize this condition to print specific lines
                print("SEGMENT " + str(segment_number) + ": " + line.lower(), end='')
                bar.update(k)
                k += 1
            else:
                log.write(line)
            if stop():
                raise KeyboardInterrupt
    except KeyboardInterrupt:
        # Handle Ctrl+C gracefully using kill_proc_tree function
        print("Ctrl+C received. Terminating process for segment number " + str(segment_number) + ".")
        log.close()
        # process.terminate()
        print("Proc PID is :" + str(proc.pid))
        gone, alive = kill_proc_tree(proc.pid, signal.SIGKILL)
        for p in alive:
            p.kill()
    finally:
        log.close()

